---
layout: post
title: YARA가 무엇인지 실습해보기
date: 2025-10-01 09:00:00 +0900
categories: [malware, Yara]
tags: [Yara, Malware, Pattern]
comments: true
---

이전에 동적 메모리 스캐너를 직접 구현하면서 바이트 패턴을 기준으로 탐지 결과를 출력해본 경험이 있었다.  

그 과정에서 자연스럽게 들었던 의문은 이것이었다.  

이런식으로 비교를 하게 된다면 너무 비효율적이고 만드는거 또한 너무 번거로운데 좋은 방법이 없나?   
실제 악성코드 진단 환경에서는 이런 패턴들을 어떤 식으로 관리하고 어떤 기준으로 탐지 판단을 내릴까?  

이 질문에 대한 답을 찾는 과정에서 YARA라는 도구를 제대로 이해해볼 필요가 있다고 느꼈다.  

---

## YARA는 무엇을 하기 위한 도구인가

YARA는 악성코드에서 자주 등장하는 문자열, 바이트, 코드 패턴 등을 rule이라는 형태로 정의하고  
파일이나 메모리 안에 해당 패턴이 존재하는지를 검사하는 도구다.  

중요한 점은 YARA가 악성 여부를 판단해주는 도구가 아니라는 것이다.

YARA는 어디까지나 이 파일에서 이런 특징들이 발견되었다라는 탐지 결과를 제공하는 도구에 가깝다.  

이 구조는 내가 직접 만들었던 메모리 스캐너와도 매우 닮아 있었다.  

패턴을 찾는 역할과 그 결과를 어떻게 해석할지는 명확히 분리되어 있다는 점에서 말이다.

---

## YARA 룰을 이해해야 하는 이유

YARA를 제대로 사용하려면 단순히 명령어를 치는 것보다 룰을 직접 작성할 수 있어야 한다고 느꼈다.  

룰의 구조를 이해하지 못하면 탐지 결과가 왜 나왔는지 설명할 수 없고 오탐인지 아닌지도 판단하기 어렵다.  

그래서 가장 먼저 YARA 룰의 기본 구조부터 살펴봤다.  

[YARA Docs](https://yara.readthedocs.io/en/latest/){:target="_blank"}

```

rule silent_banker : banker
{
    meta:
        description = "This is just an example"
        threat_level = 3
        in_the_wild = true

    strings:
        $a = {6A 40 68 00 30 00 00 6A 14 8D 91}
        $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9}
        $c = "UVODFRYSIHLNWPEJXQZAKCBGMT"

    condition:
        $a or $b or $c
}

```

이 룰을 기준으로 구조를 나눠 간단하게 정리하였다.

### rule & tags
`silent_banker`는 룰의 이름이다.  
탐지 결과에서 어떤 룰에 의해 매칭되었는지를 식별하는 기준이 된다.

`banker`는 태그로 탐지 결과를 분류하거나 나중에 처리 단계에서 조건을 나눌 때 사용된다.  

### meta
meta 영역은 탐지에는 직접적인 영향을 주지 않는다.  
대신 이 룰이 무엇을 위한 룰인지 어떤 악성코드 계열인지 같은 정보를 남기기 위한 공간이다.  

### strings
실제로 탐지할 패턴을 정의하는 핵심 영역이다.  
문자열, 헥스 바이트, 정규표현식, 와일드카드 등 다양한 방식으로 작성할 수 있다.

### condition
strings에서 정의한 패턴들을 어떤 조건에서 탐지로 볼 것인지 결정하는 영역이다.  
이 부분이 오탐과 정탐을 가르는 가장 중요한 지점이 된다.

---

## 로컬 환경에서 YARA 설치 & 실행

이제 개념을 어느 정도 이해했으니 로컬 환경에서 직접 YARA를 실행해보기로 했다.  

```bash
sudo apt-get update
sudo apt-get install yara
```

<img src="assets/img/Malware/01/1.png" width="95%" style="display:block; margin:0 auto;">
*YARA 설치 과정*

설치 후에는 버전을 확인해 명령어가 정상적으로 동작하는지 확인했다.  

```bash
yara --version
```

<img src="assets/img/Malware/01/2.png" width="95%" style="display:block; margin:0 auto;">
*YARA 버전 확인*

이제 정상적으로 설치가 되었으니 커맨드를 통해 어떤식으로 동작하는지 알아보도록 하겠다.

---

## 간단한 테스트 

복잡한 룰을 바로 쓰기보다는 YARA가 파일을 어떻게 검사하는지 감을 잡고 싶었다.  
그래서 문자열 하나만 검사하는 가장 단순한 예제를 먼저 만들어봤다.  

# test.yar  

```
rule Test_Hello
{
    strings:
        $a = "Yara_test"
    condition:
        $a
}
```

# sample.txt  

```
xxxx Yara_test aaaa
aaaa Test_yara xxxx
```

위와 같이 간단한 샘플을 만든 뒤 터미널을 통해 테스트를 했다.  

<img src="assets/img/Malware/01/3.png" width="95%" style="display:block; margin:0 auto;">
*테스트 결과*

룰을 기준으로 파일을 읽고 strings를 검사한 뒤 condition을 만족하면 결과를 출력한다.

---

## Yara-rules 오픈 소스를 사용해보자

단순 문자열 테스트를 마치고 나니 이런 생각이 들었다.  
이런 단순한 방법을 통해 찾는 방법도 있지만 오픈소스를 통해 좀 더 알아보고 싶었다.  

그래서 실제 분석 환경과 최대한 비슷하게 테스트 해보기 위해 오픈소스 YARA 룰을 직접 사용해보기로 했다.  

```bash
git clone https://github.com/Yara-Rules/rules.git
```

<img src="assets/img/Malware/01/4.png" width="95%" style="display:block; margin:0 auto;">
*rules download*

rules 디렉토리를 살펴보면 수많은 룰들이 카테고리별로 정리되어 있고 index.yar을 기준으로 관리되고 있다.  
이 구조를 보며 패턴을 코드에 하드코딩하던 방식과 달리 룰 파일로 관리하는 이유를 체감할 수 있었다.  

내가 제대로 모르는거 일수도 있지만 해당 오픈소스는 초기에 고질병 같은 버그도 있었고  
감지되는 규칙이 어디서 난건지 찾기 위해 namespace를 출력시켜도 default로 나오는 경우가 있어 조금 불편했다.  

---

## 실제 테스트 구성하기

이제 룰만 있는 상태가 아니라 실제로 검사할 대상이 필요했다.  

[MalwareBazaar](https://bazaar.abuse.ch/){:target="_blank"}을 통해 악성코드 샘플과 함께 정상 파일도 같이 준비했다.  

<img src="assets/img/Malware/01/5.png" width="95%" style="display:block; margin:0 auto;">
*dir*

---

## Python을 통한 실제 테스트 

커맨드라인으로 단일 파일을 검사하는 것까지는 충분히 확인했다.  
하지만 여러 파일을 반복적으로 검사하고 결과를 코드에서 다루려면 한계가 있었다.

그래서 YARA에서 제공하는 Python 패키지를 사용해 간단한 테스트 코드를 작성해보기로 했다.  

아래의 명령어를 통해 패키지를 먼저 설치하면 된다.  

```bash
pip install yara-python
```

# Source Code

```python
import yara
import os

rules = yara.compile(filepath="./rules/index.yar") # 룰 컴파일
target_dir = "./my_files" # 검사 대상 

# 디렉터리 내 모든 파일 순회 
for filename in os.listdir(target_dir):
    filepath = os.path.join(target_dir, filename) # 경로 생성

    if not os.path.isfile(filepath):
        continue

    matches = rules.match(filepath) # Yara 룰로 검사

    if matches:
        print("[+]", filepath)
        for m in matches:
            print("   -", m.rule) 
    else:
        print("[CLEAN]", filepath)
```

해당 코드를 이제 실행시켜보자

```bash
python3 yara_test.py
```

<img src="assets/img/Malware/01/6.png" width="95%" style="display:block; margin:0 auto;">
*YARA  결과*

결과를 보면서 가장 먼저 든 생각은 내가 생각한거랑은 좀 다르다는 것이었다.  

나는 특정 악성코드의 패턴을 룰로 등록하면 해당 악성코드를 찾아주는 단순한 도구라고 생각했다.  

하지만 탐지된 결과를 보면 단순한 문자열 시그니처만 있는게 아니라  
PE 정보, SEH, Anti-Debug 등 일반적인 API도 포함되어 있다는것이다.  

어떤식으로 커스텀을 하냐에 따라 다르겠지만 VirusTotal의 오픈 소스는 사용되는 함수들 중  
악성코드에서 주로 사용하는 함수들을 여러가지 조합하여 결과를 토해내는 방식이 제일 좋지 않나 싶긴하다.  
이 방식으로 바이러스를 탐지하는 것을 만드는건 너무 많은 시간과 개념을 요구하기에 조금 어려운거 같긴하다.  

개인적으로 나라면 악성코드 샘플을 제공해주는 사이트를 통해 정상/악성 샘플들을 충분히 모으고  
[yarGen](https://github.com/Neo23x0/yarGen/){:target="_blank"}과 같은 도구를 활용해 yar룰을 생성하고 그것을 토대로 확실한 검증을 하겠금 처리하는게 가장 효율적이지 않나 싶다.   

---

## 정리

이 글을 통해 목표로 했던 것은 YARA를 깊게 파고드는 것이 아니라 왜 이런 도구가 필요하고  
어떤 흐름으로 사용하게 되는지를 이해하는 것이었다.

기본적인 룰 작성부터 시작해 로컬 테스트, 공개 룰 활용, Python 연동까지 경험해보니  
YARA가 어떤 위치에 있는 도구인지 조금은 감이 잡혔다.

